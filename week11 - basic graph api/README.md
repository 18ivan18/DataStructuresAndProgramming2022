# Задачи от минали години

## Задача 1

Двоично наредено дърво представяме чрез следната структура:
```c++
struct Node {
    int key;          //ключ
    Node* left;      //ляво поддърво
    Node* right;     //дясно поддървo
    Node* parent;    //баща
    int bFactor;     //баланс фактор
};
```

Функциите `Node* rotateLeft(Node* root)` и `Node* rotateRight(Node* root)` правят лява и дясна
ротация съответно около root на дървото с корен root и връщат корена на ротираното дърво.
Напишете функция `void balanceOnDelete(Node*& current, Node* previous)` както и функция функция `void balanceOnInsert(Node*& current, Node* previous)`, която:
- преизчислява баланс факторите на всички върхове от current до корена на дървото след като в дървото е
било направено изтриване на непряк наследник на current. previous е наследникът на current по пътя към
изтрития елемент.
- ако след преизчисляването, баланс факторът в някой връх стане -2 или 2, то с подходящи ротации коригира
баланс фактора в граници -1 и 1, така че дървото да остане наредено.


## Задача 2
Даден е вектор v от цели числа. Казваме, че двоичното
дърво с положителни числа по върховете t представя v при следните
условия:

- v е празният вектор и t е празното дърво; или
- ако v = v[0],…,v[k-1], a m = ⌊k / 2⌋ (долна цяла част), то коренът
на t съдържа числото v[m], лявото поддърво на t представя вектора
v[0],…,v[m-1], а дясното поддърво на t представя вектора
v[m+1],…,v[k-1].

Забележка: ако k = 2, то десния подвектор считаме за празен.

- Да се реализира функция, която построява дърво, представящо
вектора v, и връща указател към корена му.

Упътване: Ако v е вектор, то с помощта на следния конструктор
`std::vector<unsigned> L(v.begin(), v.begin() + count)` ще получите
първите `count` елемента от v,
а с `std::vector<unsigned> R (v.begin() + start, v.end())`, ще
получите суфикса на v, започващ от елемента с индекс start.
Пример:
```
std::vector<unsigned> v{1, 2, 3, 4, 5, 6},
                      L(v.begin(), v.begin() + 3),
                      R(v.begin() + 4, v.end());
```
Тогава L е векторът 1, 2, 3, а R е векторът 5, 6.

- Да се реализира функция, която връща вектор, съставен от възлите
по път в дървото от корен до листо, в който сумата на елементите е
максимална.


## Задача 3
Даден е символен низ s. Казваме, че двоичното дърво със
символи по върховете t представя s при следните условия:

- s е празният низ и t е празното дърво; или
- ако s = s[0]…s[k-1], a m = ⌊k / 2⌋ (долна цяла част), то коренът
на t съдържа символа s[m], лявото поддърво на t представя низа
s[0]…s[m-1], а дясното поддърво на t представя низа s[m+1]…s[k-1].
Забележка: ако k = 2, то десния низ считаме за празен.


 - Да се реализира функция, която построява дърво, представящо низа
s, и връща указател към корена му.

Упътване: Можете да ползвате метода `std::string::substr(pos, count)`,
който връща подниз, започващ със символа с индекс pos и с count на
брой елемента. Ако пропуснете параметъра count, ще получавите суфикс
на дадения низ от позиция pos до края на низа.

Пример: 
```
std::string("abcde").substr(1, 3) → "bcd",
std::string("abcde").substr(3) → "de".
```

- Да се реализира функция, която връща низ, съставен от възлите по
 път в дървото от корен до листо, в който брой на срещанията на
 символа c е максимален.

# Основни графови алгоритми

## Задача 4
Имплементирайте ориентиран и неориентиран граф API.
Нека съдържат методите:
- toString()
и предефиниран оператор за изход
- operator<<(...)

Нека ориентираният граф да има следните методи:
- indegree(int v)
- outdegree(int v)
- reverse()

Бонус: Направете абстрактен клас граф, който е наследен от ориентирания и
неориентирания граф.

## Неориентирани графи
## Задача 5
Имплементирайте простичък graph-processing API за неориентиран граф със следните
методи:
- degree(Graph G, inv v) -> степента на върха v
- maxDegree(Graph G)
- avgDegree(Graph G)
- numberOfSelfLoops(Graph G)

**Note.**

Design pattern. Decouple graph data type from graph processing.
- Create a Graph object.
- Pass the Graph to a graph-processing routine.
- Query the graph-processing routine for information.

### Каква е сложността на всеки един от алгоритмите по време и памет? 
Това условие се
отнася за всяка една задача.

## Задача 6
Имплементирайте Graph client, който използва DFS и BFS за неориентиран граф, за да
провери дали има път от даден връх до всички други. Имплементирайте DFS
рекурсивно и нерекурсивно.

## Задача 7
Имплементирайте Graph client за неориентиран граф, който намира броят на
свързаните компоненти в граф, както и отговаря на въпроса дали 2 върха са свързани.

## Задача 8
Имплементирайте Graph client, който проверява дали неориентиран граф е:
- цикличен
- двуделен

## Задача 9
### Symbol graph. 
Често срещано приложение е обработването на графи, дефинирани чрез
файлове, стрингове и/или индекси, които не са цели числа. Трябва да се справим с
входни данни със следните свойства:
- Имената на върховете са стрингове.
- Специално обозначен разделител дели имената на върховете.
- Всеки ред съдържа два върха, разделени с оказания разделител.
- Броят върхове и ребра не са експлицитно посочени.

Бонус, ако го имплементирате, така че да чете подаденият вход само веднъж.
Обяснение: интуитивната идея е да се прочете входът веднъж, за да се преброят
върховете, и втори път, за да се добавят ребрата.

Примерен тестов клиент:
```c++
std::string filename = args[0];
std::string delim = args[1];
SymbolGraph sg = new SymbolGraph(filename, delim);
Graph G = sg.G();
while (std::cin)
{
    std::string source;
    std::cin.getline(source);
    for (int w : G.adj(sg.index(source))){
        std::cout << " " << sg.name(w));
    }
    std::cout << std::endl;
}
```

## Ориентирани графи
## Задача 10
Имплементирайте Graph client, който сортира топологично DAG.

## Задача 11
Имплементирайте Graph client, който проверява дали ориентиран граф:
- е цикличен
- имплементира алгоритъмът на Kosaraju за силно свързани компоненти.


## Задача 12
Имплементирайте Graph client, който проверява дали ориентиран граф има Ойлеров:
- път
- цикъл
